#!/usr/bin/env python3
import subprocess
import argparse
import sys

def find_streams_from_url(video_url, resolution):
    """
    Calls the yt-dlp command-line tool to find the URLs for the specified
    video and audio streams, with fallbacks for resolutions and codecs.

    Args:
        video_url (str): The URL of the YouTube video.
        resolution (int): The preferred video resolution (e.g., 1080, 720).

    Returns:
        tuple: A tuple containing the video URL and audio URL, or (None, None) if not found.
    """
    try:
        # This is a powerful format selector that handles all the fallbacks
        # It prioritizes MP4 video and M4A audio, then falls back to WebM/Opus,
        # then falls back to the next highest resolution.
        format_string = (
            f"bestvideo[height<={resolution}][ext=mp4]+bestaudio[ext=m4a]/"
            f"bestvideo[height<={resolution}][ext=webm]+bestaudio[ext=webm]/"
            f"best"
        )

        # Construct the command to get the video and audio URLs directly
        command = [
            "yt-dlp",
            "--format", format_string,
            "--get-url",
            "--no-playlist",
            video_url
        ]
        
        # Run the command and capture the output
        process = subprocess.run(command, capture_output=True, text=True, check=True)
        
        # The output is expected to be two lines: video URL and audio URL
        urls = process.stdout.strip().split('\n')
        
        if len(urls) == 2:
            return urls[0], urls[1]
        else:
            print("Error: Could not retrieve both video and audio URLs.", file=sys.stderr)
            return None, None
            
    except FileNotFoundError:
        print("Error: 'yt-dlp' command not found. Please ensure it is installed and in your system's PATH.", file=sys.stderr)
        return None, None
    except subprocess.CalledProcessError as e:
        print(f"Error calling yt-dlp: {e.stderr}", file=sys.stderr)
        return None, None
    except Exception as e:
        print(f"An unexpected error occurred: {e}", file=sys.stderr)
        return None, None

def stream_with_ffmpeg_mpv(video_url, audio_url, cache_size, fullscreen_screen):
    """
    Combines the given video and audio streams using ffmpeg and pipes the output
    to mpv for playback.

    Args:
        video_url (str): The URL of the video stream.
        audio_url (str): The URL of the audio stream.
        cache_size (int): The cache size for mpv in kilobytes.
        fullscreen_screen (int): The screen to use for fullscreen playback.
    """
    # ffmpeg command to combine video and audio and pipe to stdout
    ffmpeg_command = [
        "ffmpeg",
        "-hide_banner",
        "-stats", "-v", "panic",
        "-i", video_url,
        "-i", audio_url,
        "-c:v", "copy",
        "-c:a", "copy",
        "-map", "0:v:0",
        "-map", "1:a:0",
        "-f", "matroska",
        "pipe:1"  # Pipe the output to stdout
    ]

    # mpv command to read from stdin, now with a configurable cache size and screen
    mpv_command = [
        "mpv",
        "--cache", str(cache_size),
        "--no-terminal",
        "--fs",
        f"--fs-screen={fullscreen_screen}",
        "-"  # Read from stdin
    ]
    
    # Use Popen for both processes so we can manage them
    ffmpeg_process = None
    mpv_process = None

    try:
        # Start the ffmpeg process
        ffmpeg_process = subprocess.Popen(ffmpeg_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        
        # Start the mpv process and connect its stdin to ffmpeg's stdout
        mpv_process = subprocess.Popen(mpv_command, stdin=ffmpeg_process.stdout)
        
        # Wait for mpv to finish
        mpv_process.wait()

    except FileNotFoundError:
        print("Error: 'ffmpeg' or 'mpv' command not found. Please ensure they are installed and in your system's PATH.", file=sys.stderr)
    except Exception as e:
        print(f"An unexpected error occurred during streaming: {e}", file=sys.stderr)
    finally:
        # Ensure processes are terminated cleanly, regardless of how the script exits
        if mpv_process and mpv_process.poll() is None:
            mpv_process.terminate()
        if ffmpeg_process and ffmpeg_process.poll() is None:
            ffmpeg_process.terminate()

def main():
    parser = argparse.ArgumentParser(description="Stream a YouTube video with resolution, cache, and fullscreen options.")
    parser.add_argument(
        '-i', '--input', 
        required=True, 
        help="The URL of the YouTube video."
    )
    # Argument for resolution with autocompletion
    parser.add_argument(
        '-r', '--resolution',
        type=int,
        default=1080,
        choices=[2160, 1440, 1080, 720, 480, 360, 240, 144],
        help="The desired video resolution. Defaults to 1080p."
    )
    # Argument for cache size, with a more descriptive help message
    parser.add_argument(
        '-c', '--cache',
        type=int,
        default=2048,
        help="MPV cache size in kilobytes. Accepts a value between 0 and 8192."
    )
    # New argument for the fullscreen screen
    parser.add_argument(
        '-f', '--fullscreen-screen',
        type=int,
        default=1,
        help="The screen number to use for fullscreen playback. Defaults to 1 (primary display)."
    )
    
    args = parser.parse_args()
    
    # Input validation for cache size
    if not 0 <= args.cache <= 8192:
        print("Error: Cache size must be between 0 and 8192.", file=sys.stderr)
        sys.exit(1)

    video_url, audio_url = find_streams_from_url(args.input, args.resolution)

    if video_url and audio_url:
        try:
            stream_with_ffmpeg_mpv(video_url, audio_url, args.cache, args.fullscreen_screen)
        except KeyboardInterrupt:
            print("\nStreaming stopped by user.")
            sys.exit(0)
    else:
        print("Could not find suitable video and audio streams. Cannot proceed with streaming.")

if __name__ == '__main__':
    main()
