#!/usr/bin/env python3
import subprocess
import argparse
import sys
import os
import signal

def find_streams_from_url(video_url, resolution, show_output):
    """
    Calls the yt-dlp command-line tool to find the URLs for the specified
    video and audio streams, with fallbacks for resolutions and codecs.

    Args:
        video_url (str): The URL of the YouTube video.
        resolution (int): The preferred video resolution (e.g., 1080, 720).
        show_output (bool): If True, prints status messages to the terminal.

    Returns:
        tuple: A tuple containing the video URL and audio URL, or (None, None) if not found.
    """
    try:
        # This is a powerful format selector that handles all the fallbacks.
        # It prioritizes MP4 video and M4A audio, then falls back to WebM/Opus,
        # and finally falls back to the next highest resolution.
        format_string = (
            f"bestvideo[height<={resolution}][ext=mp4]+bestaudio[ext=m4a]/"
            f"bestvideo[height<={resolution}][ext=webm]+bestaudio[ext=webm]/"
            f"best"
        )

        # Construct the command to get the video and audio URLs directly
        command = [
            "yt-dlp",
            "--format", format_string,
            "--get-url",
            "--no-playlist",
            video_url
        ]
        
        # Run the command and capture the output
        process = subprocess.run(command, capture_output=True, text=True, check=True)
        
        # The output is expected to be two lines: video URL and audio URL
        urls = process.stdout.strip().split('\n')
        
        if len(urls) == 2:
            return urls[0], urls[1]
        else:
            if show_output:
                print("Error: Could not retrieve both video and audio URLs.", file=sys.stderr)
            return None, None
            
    except FileNotFoundError:
        if show_output:
            print("Error: 'yt-dlp' command not found. Please ensure it is installed and in your system's PATH.", file=sys.stderr)
        return None, None
    except subprocess.CalledProcessError as e:
        if show_output:
            print(f"Error calling yt-dlp: {e.stderr}", file=sys.stderr)
        return None, None
    except Exception as e:
        if show_output:
            print(f"An unexpected error occurred: {e}", file=sys.stderr)
        return None, None

def get_video_duration(video_url, show_output):
    """
    Calls yt-dlp to get the total duration of the video.

    Args:
        video_url (str): The URL of the YouTube video.
        show_output (bool): If True, prints status messages to the terminal.

    Returns:
        float: The video duration in seconds, or None if not found.
    """
    try:
        command = [
            "yt-dlp",
            "--get-duration",
            "--no-playlist",
            video_url
        ]
        process = subprocess.run(command, capture_output=True, text=True, check=True)
        # The output is expected to be a single string representing the duration
        duration_string = process.stdout.strip()
        
        # Convert duration to seconds for mpv --length
        if ':' in duration_string:
            parts = duration_string.split(':')
            seconds = int(parts[-1])
            if len(parts) > 1:
                seconds += int(parts[-2]) * 60
            if len(parts) > 2:
                seconds += int(parts[-3]) * 3600
            return float(seconds)
        else:
            return float(duration_string)
            
    except Exception as e:
        if show_output:
            print(f"Could not get video duration: {e}", file=sys.stderr)
        return None

def stream_with_ffmpeg_mpv(video_url, audio_url, cache_size, fullscreen_screen, duration, show_output):
    """
    Combines the given video and audio streams using ffmpeg and pipes the output
    to mpv for playback. This version includes a more robust process
    termination to prevent hanging ffmpeg processes.

    Args:
        video_url (str): The URL of the video stream.
        audio_url (str): The URL of the audio stream.
        cache_size (int): The cache size for mpv in kilobytes.
        fullscreen_screen (int): The screen to use for fullscreen playback.
        duration (float): The total duration of the video in seconds.
        show_output (bool): If True, prints status messages to the terminal.
    """
    
    stdout_target = sys.stdout if show_output else subprocess.DEVNULL
    stderr_target = sys.stderr if show_output else subprocess.DEVNULL

    # ffmpeg command to combine video and audio and pipe to stdout
    ffmpeg_command = [
        "ffmpeg",
        "-hide_banner",
        "-stats", "-v", "panic",
        "-i", video_url,
        "-i", audio_url,
        "-c:v", "copy",
        "-c:a", "copy",
        "-map", "0:v:0",
        "-map", "1:a:0",
        "-f", "matroska",
        "pipe:1"  # Pipe the output to stdout
    ]

    # mpv command to read from stdin, with a configurable cache size and screen
    # As per user's request, using the --cache flag. Note that --demuxer-max-bytes is the modern
    # equivalent for piped streams, but this will work for now.
    mpv_command = [
        "mpv",
        "-",  # Read from stdin
        "--cache", f"{cache_size}",
        "--fs",
        f"--fs-screen={fullscreen_screen}",
        "--force-seekable=yes",
    ]
    
    # Add the duration flag if available
    if duration:
        mpv_command.append(f"--length={duration}")

    ffmpeg_process = None
    mpv_process = None

    try:
        # Start the ffmpeg process in a new process group. This is key for robust termination.
        ffmpeg_process = subprocess.Popen(ffmpeg_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, start_new_session=True)
        
        # Start the mpv process and connect its stdin to ffmpeg's stdout
        mpv_process = subprocess.Popen(mpv_command, stdin=ffmpeg_process.stdout, stdout=stdout_target, stderr=stderr_target)
        
        # Close the stdout pipe in the parent process immediately. This is crucial for a clean exit.
        ffmpeg_process.stdout.close()
        
        # Wait for mpv to exit. This is a blocking call.
        mpv_process.wait()
        
    except FileNotFoundError:
        if show_output:
            print("Error: 'ffmpeg' or 'mpv' command not found. Please ensure they are installed and in your system's PATH.", file=sys.stderr)
    except Exception as e:
        if show_output:
            print(f"An unexpected error occurred during streaming: {e}", file=sys.stderr)
    finally:
        # Failsafe to ensure no processes are left hanging.
        if mpv_process and mpv_process.poll() is None:
            mpv_process.kill()
        
        # Terminate the entire ffmpeg process group
        if ffmpeg_process and ffmpeg_process.poll() is None:
            os.killpg(ffmpeg_process.pid, signal.SIGKILL)
            
        # Wait for ffmpeg to finish its cleanup
        if ffmpeg_process:
            ffmpeg_process.wait()


def main():
    parser = argparse.ArgumentParser(description="Stream a YouTube video with resolution, cache, and fullscreen options.")
    parser.add_argument(
        '-i', '--input', 
        required=True, 
        help="The URL of the YouTube video."
    )
    # Argument for resolution with autocompletion
    parser.add_argument(
        '-r', '--resolution',
        type=int,
        default=1080,
        choices=[2160, 1440, 1080, 720, 480, 360, 240, 144],
        help="The desired video resolution. Defaults to 1080p."
    )
    # Argument for cache size, with a more descriptive help message
    parser.add_argument(
        '-c', '--cache',
        type=int,
        default=2048,
        help="MPV cache size in kilobytes. Accepts a value between 0 and 8192."
    )
    # New argument for the fullscreen screen
    parser.add_argument(
        '-f', '--fullscreen-screen',
        type=int,
        default=1,
        help="The screen number to use for fullscreen playback. Defaults to 1 (primary display)."
    )
    # New argument to control terminal output
    parser.add_argument(
        '-t', '--terminal-output',
        type=str,
        default='on',
        choices=['on', 'off'],
        help="Controls whether to show terminal output. 'on' shows output (default), 'off' suppresses it."
    )
    
    args = parser.parse_args()
    
    # Input validation for cache size
    if not 0 <= args.cache <= 8192:
        print("Error: Cache size must be between 0 and 8192.", file=sys.stderr)
        sys.exit(1)

    show_output = (args.terminal_output.lower() == 'on')

    video_url, audio_url = find_streams_from_url(args.input, args.resolution, show_output)
    duration = get_video_duration(args.input, show_output)

    if video_url and audio_url:
        try:
            stream_with_ffmpeg_mpv(video_url, audio_url, args.cache, args.fullscreen_screen, duration, show_output)
        except KeyboardInterrupt:
            if show_output:
                print("\nStreaming stopped by user.")
            sys.exit(0)
    else:
        # Only print this error if output is explicitly turned on.
        if show_output:
            print("Could not find suitable video and audio streams. Cannot proceed with streaming.", file=sys.stderr)

if __name__ == '__main__':
    main()
